{"version":3,"sources":["hooks/config.ts","utils.ts","components/ConfigForm.tsx","hooks/streams.ts","hooks/messages.ts","components/WebRTCConnector.tsx","components/StatusMessages.tsx","api/dataChannel.ts","components/VideoContainer.tsx","components/MainFrame.tsx","index.tsx"],"names":["receiveOnlyState","atom","key","default","wsUrlState","roomIdState","strLength","result","push","charAt","Math","floor","random","length","join","randomString","useGetConfigValues","wsUrl","useRecoilValue","roomId","receiveOnly","useConnectInputElement","state","useRecoilState","value","setValue","useCallback","e","target","Inputs","styled","form","InputRow","div","TextBox","input","ConfigForm","onChangeWsUrl","onChangeRoomId","htmlFor","id","type","onChange","localStreamState","remoteStreamState","remoteAudioStreamState","dataChannelState","useGetStreams","localStream","remoteStream","remoteAudioStream","dataChannel","messagesState","Buttons","Button","button","props","disabled","disabledCss","css","WebRTCConnector","useState","canConnect","setCanConnect","canDisconnect","setCanDisconnect","connection","setConnection","config","setLocalStream","useSetRecoilState","setRemoteStream","setAudioRemoteStream","setDataChannel","log","useRecoilCallback","snapshot","set","msg","a","getPromise","messages","newMessages","Object","assign","shift","disconnected","getTracks","forEach","track","stop","connect","options","defaultOptions","audio","direction","video","conn","AyameConnection","on","console","kind","streams","createDataChannel","ordered","then","dc","navigator","mediaDevices","getUserMedia","disconnect","onClick","Frame","Message","StatusMessages","map","line","index","sendEvent","channel","data","readyState","send","JSON","stringify","warn","getOffsetPosition","rect","currentTarget","getBoundingClientRect","x","clientX","left","y","clientY","top","t","timeStamp","Videos","shown","RemoteVideo","LocalVideo","VideoContainer","localVideoRef","useRef","remoteVideoRef","remoteAudioRef","isMousePressed","setMousePressed","initializeValue","array","setter","appendValue","newValue","concat","clearValue","useArrayState","events","appendEvent","clearEvents","useLayoutEffect","current","srcObject","useEffect","resizeObserver","ResizeObserver","entries","width","ceil","contentRect","height","observe","handleTouchStart","event","handleTouchEnd","sendTouchEvents","handleMouseDown","handleMouseUp","handleMouseLeave","ref","autoPlay","onMouseDown","onMouseUp","onMouseLeave","muted","Main","Title","Spacer","MainFrame","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.171de777.chunk.js","sourcesContent":["import { atom, useRecoilValue, useRecoilState, RecoilState } from 'recoil';\nimport { useCallback } from 'react';\nimport { randomString } from '../utils';\n\nconst DefaultWsUrl = 'wss://0j1sxcggc0.execute-api.ap-northeast-1.amazonaws.com/Dev';\n\nconst receiveOnlyState = atom({\n    key: 'config/receiveOnly',\n    default: true,\n});\nconst wsUrlState = atom({\n    key: 'config/wsUrl',\n    default: DefaultWsUrl,\n});\nconst roomIdState = atom({\n    key: 'config/roomId',\n    default: randomString(8),\n});\n\nexport interface Config {\n    wsUrl: string;\n    roomId: string;\n    receiveOnly: boolean;\n}\nexport function useGetConfigValues(): Config {\n    const wsUrl = useRecoilValue(wsUrlState);\n    const roomId = useRecoilValue(roomIdState);\n    const receiveOnly = useRecoilValue(receiveOnlyState);\n    return { wsUrl, roomId, receiveOnly };\n}\n\nexport function useConnectReceiveOnlyState(): [\n    boolean,\n    React.ChangeEventHandler<HTMLInputElement>,\n] {\n    const [value, setValue] = useRecoilState(receiveOnlyState);\n    const onChangeValue = useCallback(\n        (e: React.ChangeEvent<HTMLInputElement>) => setValue(e.target.checked),\n        [setValue],\n    );\n    return [value, onChangeValue];\n}\nexport function useConnectWsUrlState(): [\n    string,\n    React.ChangeEventHandler<HTMLInputElement>,\n] {\n    return useConnectInputElement(wsUrlState);\n}\nexport function useConnectRoomIdState(): [\n    string,\n    React.ChangeEventHandler<HTMLInputElement>,\n] {\n    return useConnectInputElement(roomIdState);\n}\n\nfunction useConnectInputElement(\n    state: RecoilState<string>,\n): [string, React.ChangeEventHandler<HTMLInputElement>] {\n    const [value, setValue] = useRecoilState(state);\n    const onChangeValue = useCallback(\n        (e: React.ChangeEvent<HTMLInputElement>) => setValue(e.target.value),\n        [setValue],\n    );\n    return [value, onChangeValue];\n}\n","import { useState, useCallback } from 'react';\n\nexport function randomString(strLength: number): string {\n    const result = [];\n    const charSet = '0123456789';\n    while (strLength--) {\n        result.push(charSet.charAt(Math.floor(Math.random() * charSet.length)));\n    }\n    return result.join('');\n}\n\nexport function useArrayState<T>(\n    initializeValue: T[] = [],\n): [T[], (value: T) => void, () => void] {\n    const [array, setter] = useState<T[]>(initializeValue);\n    const appendValue = useCallback(\n        (value: T) => {\n            const newValue = array.concat(value);\n            setter(newValue);\n        },\n        [array],\n    );\n    const clearValue = useCallback(() => {\n        setter([]);\n    }, []);\n    return [array, appendValue, clearValue];\n}\n","import React from 'react';\nimport styled from 'styled-components';\nimport { useConnectWsUrlState, useConnectRoomIdState } from 'hooks/config';\n\nconst ConfigForm: React.FC = () => {\n    const [wsUrl, onChangeWsUrl] = useConnectWsUrlState();\n    const [roomId, onChangeRoomId] = useConnectRoomIdState();\n    // const [receiveOnly, onChangeReceiveOnly] = useConnectReceiveOnlyState();\n\n    return (\n        <Inputs>\n            <InputRow>\n                <label htmlFor=\"url\">シグナリングサーバのURL:</label>\n                <TextBox\n                    id=\"url\"\n                    type=\"text\"\n                    onChange={onChangeWsUrl}\n                    value={wsUrl}\n                />\n            </InputRow>\n            <InputRow>\n                <label htmlFor=\"roomId\">部屋のID:</label>\n                <TextBox\n                    id=\"roomId\"\n                    type=\"text\"\n                    onChange={onChangeRoomId}\n                    value={roomId}\n                />\n            </InputRow>\n            {/* <InputRow>\n                <label htmlFor=\"receive-only\">受信Only:</label>\n                <CheckBox\n                    id=\"receive-only\"\n                    type=\"checkbox\"\n                    onChange={onChangeReceiveOnly}\n                    checked={receiveOnly}\n                />\n            </InputRow> */}\n        </Inputs>\n    );\n};\n\nconst Inputs = styled.form`\n    margin: 0 2rem;\n`;\nconst InputRow = styled.div`\n    margin: 1rem;\n`;\n\nconst TextBox = styled.input`\n    width: 12rem;\n    margin: 0 0.2rem;\n`;\n// const CheckBox = styled.input`\n//     margin: 0 0.2rem;\n// `;\n\nexport default ConfigForm;\n","import { atom, useRecoilValue, useSetRecoilState } from 'recoil';\n\nconst localStreamState = atom<MediaStream | null>({\n    key: 'streams/localStream',\n    default: null,\n});\nconst remoteStreamState = atom<MediaStream | null>({\n    key: 'streams/remoteStream',\n    default: null,\n});\nconst remoteAudioStreamState = atom<MediaStream | null>({\n    key: 'streams/remoteAudioStream',\n    default: null,\n});\nconst dataChannelState = atom<RTCDataChannel | null>({\n    key: 'streams/dataChannel',\n    default: null,\n});\n\nexport function useGetStreams() {\n    const localStream = useRecoilValue(localStreamState);\n    const remoteStream = useRecoilValue(remoteStreamState);\n    const remoteAudioStream = useRecoilValue(remoteAudioStreamState);\n    const dataChannel = useRecoilValue(dataChannelState);\n    return { localStream, remoteStream, remoteAudioStream, dataChannel };\n}\n\nexport function useSetLocalStream() {\n    return useSetRecoilState(localStreamState);\n}\n\nexport function useSetRemoteStream() {\n    return useSetRecoilState(remoteStreamState);\n}\n\nexport function useSetAudioRemoteStream() {\n    return useSetRecoilState(remoteAudioStreamState);\n}\n\nexport function useSetDataChannel() {\n    return useSetRecoilState(dataChannelState);\n}\n","import { atom, useRecoilValue, useRecoilCallback } from 'recoil';\n\nconst maxMessagesCount = 10;\n\nconst messagesState = atom<string[]>({\n    key: 'messages',\n    default: [],\n});\n\nexport function useGetMessages(): string[] {\n    return useRecoilValue(messagesState);\n}\n\nexport function useAppendMessage() {\n    return useRecoilCallback(({ snapshot, set }) => async (msg: string) => {\n        const messages = await snapshot.getPromise(messagesState);\n        const newMessages = Object.assign([], messages);\n        newMessages.push(msg);\n        while (newMessages.length > maxMessagesCount) {\n            newMessages.shift();\n        }\n        set(messagesState, newMessages);\n    });\n}\n","import React, { useCallback, useState } from 'react';\nimport styled, { css } from 'styled-components';\nimport { useGetConfigValues } from 'hooks/config';\nimport {\n    connection as AyameConnection,\n    defaultOptions,\n} from '@open-ayame/ayame-web-sdk';\nimport Connection from '@open-ayame/ayame-web-sdk/dist/connection';\nimport {\n    useGetStreams,\n    useSetLocalStream,\n    useSetRemoteStream,\n    useSetAudioRemoteStream,\n    useSetDataChannel,\n} from 'hooks/streams';\nimport { useAppendMessage } from 'hooks/messages';\n\nconst DataChannelLabel = 'android-rc data';\n\nconst WebRTCConnector: React.FC = () => {\n    const [canConnect, setCanConnect] = useState(true);\n    const [canDisconnect, setCanDisconnect] = useState(false);\n\n    const [connection, setConnection] = useState<Connection>();\n    const config = useGetConfigValues();\n    const { localStream } = useGetStreams();\n    const setLocalStream = useSetLocalStream();\n    const setRemoteStream = useSetRemoteStream();\n    const setAudioRemoteStream = useSetAudioRemoteStream();\n    const setDataChannel = useSetDataChannel();\n    const log = useAppendMessage();\n\n    const disconnected = useCallback(() => {\n        if (localStream !== null) {\n            localStream.getTracks().forEach((track) => track.stop());\n        }\n        setLocalStream(null);\n        setCanConnect(true);\n        setCanDisconnect(false);\n    }, [localStream, setLocalStream]);\n\n    const connect = useCallback(async () => {\n        setCanConnect(false);\n\n        let options = defaultOptions;\n        if (config.receiveOnly) {\n            options.audio.direction = 'recvonly';\n            options.video.direction = 'recvonly';\n        }\n        // if (['H264', 'VP8', 'VP9'].includes(this.props.videoCodec)) {\n        //   options.video.codec = this.props.videoCodec;\n        // }\n        const conn = AyameConnection(config.wsUrl, config.roomId, options);\n        conn.on('disconnect', () => {\n            setRemoteStream(null);\n            setDataChannel(null);\n            log('Disconnected.');\n            disconnected();\n        });\n        conn.on('addstream', (e: RTCTrackEvent) => {\n            console.log('addstream', e.track.kind);\n            if (e.track.kind === 'audio') {\n                setAudioRemoteStream(e.streams[0]);\n                log('Connected to remote audio.');\n            } else {\n                setRemoteStream(e.streams[0]);\n                log('Connected to remote client.');\n            }\n        });\n        conn.on('open', () => {\n            setConnection(conn);\n            conn.createDataChannel(DataChannelLabel, { ordered: true }).then(\n                (dc) => {\n                    setDataChannel(dc);\n                    log(`  Created Data Channel. ${dc != null}`);\n                },\n            );\n            log('Connected to signaling server.');\n            setCanDisconnect(true);\n        });\n        conn.on('connect', () => {\n            log('  Connect P2P Channel.');\n        });\n        conn.on('datachannel', (dc: RTCDataChannel | null) => {\n            setDataChannel(dc);\n            log(`  Receive Data Channel. ${dc != null}`);\n        });\n        let localStream: MediaStream | null = null;\n        if (!config.receiveOnly) {\n            localStream = await navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true,\n            });\n        }\n        log(`Start a ${config.receiveOnly ? 'receive only ' : ''}connection.`);\n        await conn.connect(localStream);\n        setLocalStream(localStream);\n    }, [\n        config.receiveOnly,\n        config.roomId,\n        config.wsUrl,\n        disconnected,\n        log,\n        setAudioRemoteStream,\n        setDataChannel,\n        setLocalStream,\n        setRemoteStream,\n    ]);\n\n    const disconnect = useCallback(() => {\n        if (connection != null) {\n            connection.disconnect();\n        }\n        disconnected();\n    }, [connection, disconnected]);\n\n    return (\n        <Buttons>\n            <Button type=\"button\" onClick={connect} disabled={!canConnect}>\n                接続\n            </Button>\n            <Button\n                type=\"button\"\n                onClick={disconnect}\n                disabled={!canDisconnect}\n            >\n                切断\n            </Button>\n        </Buttons>\n    );\n};\n\nconst Buttons = styled.div`\n    margin: 0 2rem;\n`;\nconst Button = styled.button`\n    height: 2.75em;\n    width: 8em;\n    margin: 0 5px 20px 5px;\n    padding: 0.5em 0.7em 0.5em 0.7em;\n    background-color: #4285f4;\n    border: none;\n    border-radius: 2px;\n    box-shadow: 1px 1px 5px 0 rgba(0, 0, 0, 0.5);\n    color: white;\n    font-size: 0.8em;\n    cursor: pointer;\n    ${(props) => props.disabled && disabledCss}\n`;\nconst disabledCss = css`\n    opacity: 0.5;\n    cursor: default;\n`;\n\nexport default WebRTCConnector;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { useGetMessages } from '../hooks/messages';\n\nconst StatusMessages: React.FC = () => {\n    const messages = useGetMessages();\n\n    return (\n        <Frame>\n            {messages.map((line, index) => (\n                <Message key={index}>{line}</Message>\n            ))}\n        </Frame>\n    );\n};\n\nconst Frame = styled.div`\n    margin: 1rem;\n    padding: 0.5rem;\n    border: solid 1px #333;\n`;\nconst Message = styled.div`\n    color: #333;\n`;\n\nexport default StatusMessages;\n","type SendData =\n    | {\n          id: number;\n          type: 'config';\n          data: ConfigEventData;\n      }\n    | {\n          id: number;\n          type: 'touch';\n          data: TouchEventData[];\n      };\n\nexport interface ConfigEventData {\n    height: number;\n    width: number;\n}\n\nexport interface TouchEventData {\n    x: number;\n    y: number;\n    t: number;\n}\n\nexport function sendConfigEvent(\n    channel: RTCDataChannel | null,\n    data: ConfigEventData,\n): void {\n    sendEvent(channel, {\n        id: 0,\n        type: 'config',\n        data,\n    });\n}\n\nexport function sendTouchEvents(\n    channel: RTCDataChannel | null,\n    data: TouchEventData[],\n): void {\n    sendEvent(channel, {\n        id: 0,\n        type: 'touch',\n        data,\n    });\n}\n\nlet id = 1;\n\nfunction sendEvent(channel: RTCDataChannel | null, data: SendData) {\n    if (channel == null || channel.readyState !== 'open') {\n        console.warn(\n            'Fail to send event. Because the data channel is null or not opened.',\n            data,\n        );\n        return;\n    }\n    data.id = id++;\n    channel.send(JSON.stringify(data));\n}\n","import React, {\n    useRef,\n    useLayoutEffect,\n    useCallback,\n    useState,\n    useEffect,\n} from 'react';\nimport styled, { css } from 'styled-components';\nimport { useGetConfigValues } from 'hooks/config';\nimport { useGetStreams } from 'hooks/streams';\nimport { useArrayState } from '../utils';\nimport {\n    sendTouchEvents,\n    TouchEventData,\n    sendConfigEvent,\n} from '../api/dataChannel';\n\nconst VideoContainer: React.FC = () => {\n    const { receiveOnly } = useGetConfigValues();\n    const localVideoRef = useRef<HTMLVideoElement>(null);\n    const remoteVideoRef = useRef<HTMLVideoElement>(null);\n    const remoteAudioRef = useRef<HTMLAudioElement>(null);\n    const {\n        localStream,\n        remoteStream,\n        remoteAudioStream,\n        dataChannel,\n    } = useGetStreams();\n\n    const [isMousePressed, setMousePressed] = useState(false);\n    const [events, appendEvent, clearEvents] = useArrayState<TouchEventData>();\n\n    useLayoutEffect(() => {\n        if (localVideoRef.current) {\n            localVideoRef.current.srcObject = localStream;\n        }\n    }, [localStream]);\n    useLayoutEffect(() => {\n        if (remoteVideoRef.current) {\n            remoteVideoRef.current.srcObject = remoteStream;\n        }\n    }, [remoteStream]);\n    useLayoutEffect(() => {\n        if (remoteAudioRef.current) {\n            remoteAudioRef.current.srcObject = remoteAudioStream;\n        }\n    }, [remoteAudioStream]);\n    useEffect(() => {\n        const resizeObserver = new ResizeObserver((entries) => {\n            const width = Math.ceil(entries[0].contentRect.width);\n            const height = Math.ceil(entries[0].contentRect.height);\n\n            console.log(` Send Config Event: height=${height}, width=${width}`);\n            sendConfigEvent(dataChannel, { height, width });\n        });\n\n        remoteVideoRef.current &&\n            resizeObserver.observe(remoteVideoRef.current);\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, [dataChannel]);\n\n    const handleTouchStart = useCallback(\n        (event: TouchEventData) => {\n            setMousePressed(true);\n            appendEvent(event);\n        },\n        [appendEvent],\n    );\n    const handleTouchEnd = useCallback(\n        (event: TouchEventData) => {\n            const data = events.concat(event);\n            console.log('  Send Touch Events', data);\n            sendTouchEvents(dataChannel, data);\n\n            setMousePressed(false);\n            clearEvents();\n        },\n        [clearEvents, dataChannel, events],\n    );\n\n    const handleMouseDown = useCallback(\n        (e: React.MouseEvent<HTMLVideoElement>) => {\n            const event = getOffsetPosition(e);\n            console.log('onMouseDown', e, event);\n            handleTouchStart(event);\n        },\n        [handleTouchStart],\n    );\n    const handleMouseUp = useCallback(\n        (e: React.MouseEvent<HTMLVideoElement>) => {\n            if (isMousePressed) {\n                const event = getOffsetPosition(e);\n                console.log('onMouseUp', e, event);\n                handleTouchEnd(event);\n            }\n        },\n        [handleTouchEnd, isMousePressed],\n    );\n    const handleMouseLeave = useCallback(\n        (e: React.MouseEvent<HTMLVideoElement>) => {\n            if (isMousePressed) {\n                const event = getOffsetPosition(e);\n                console.log('onMouseLeave', e, event);\n                handleTouchEnd(event);\n            }\n        },\n        [handleTouchEnd, isMousePressed],\n    );\n\n    return (\n        <Videos shown={remoteStream != null}>\n            <RemoteVideo\n                ref={remoteVideoRef}\n                autoPlay\n                onMouseDown={handleMouseDown}\n                onMouseUp={handleMouseUp}\n                onMouseLeave={handleMouseLeave}\n            />\n            <audio ref={remoteAudioRef} autoPlay />\n            {!receiveOnly && <LocalVideo ref={localVideoRef} autoPlay muted />}\n        </Videos>\n    );\n};\n\nfunction getOffsetPosition(\n    e: React.MouseEvent<HTMLVideoElement>,\n): TouchEventData {\n    const target = e.currentTarget;\n    const rect = target.getBoundingClientRect();\n    return {\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n        t: Math.floor(e.timeStamp),\n    };\n}\n\nconst Videos = styled.div<{ shown: boolean }>`\n    font-size: 0;\n    position: absolute;\n    transition: all 1s;\n    height: 100%;\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n\n    ${(props) =>\n        props.shown\n            ? css`\n                  background: rgba(0, 0, 0, 0.6);\n              `\n            : css`\n                  display: none;\n              `}\n`;\nconst RemoteVideo = styled.video`\n    max-height: 90%;\n    max-width: 90%;\n    object-fit: contain;\n    transition: opacity 1s;\n`;\nconst LocalVideo = styled.video`\n    z-index: 2;\n    position: absolute;\n    border: 1px solid gray;\n    bottom: 0px;\n    right: 20px;\n    max-height: 30%;\n    max-width: 30%;\n    transition: opacity 1s;\n`;\n\nexport default VideoContainer;\n","import React from 'react';\nimport styled from 'styled-components';\nimport ConfigForm from './ConfigForm';\nimport WebRTCConnector from './WebRTCConnector';\nimport StatusMessages from './StatusMessages';\nimport VideoContainer from './VideoContainer';\n\nconst MainFrame: React.FC = () => {\n    return (\n        <Main>\n            <Title>WebRTC Test Client.</Title>\n            <ConfigForm />\n            <WebRTCConnector />\n            <Spacer />\n            <StatusMessages />\n\n            <VideoContainer />\n        </Main>\n    );\n};\n\nconst Main = styled.div`\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    justify-items: center;\n`;\nconst Title = styled.div`\n    margin: 2rem;\n    font-size: 2rem;\n`;\nconst Spacer = styled.div`\n    flex: 1;\n`;\n\nexport default MainFrame;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport MainFrame from 'components/MainFrame';\nimport { RecoilRoot } from 'recoil';\n\nReactDOM.render(\n    <React.StrictMode>\n        <RecoilRoot>\n            <MainFrame />\n        </RecoilRoot>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}